Analyze or choose between n8n inline expressions and Code Node following these guidelines:

Key Differences:
1. Location & Usage:
   Inline Expressions:
   - Used directly in node parameters
   - Toggle between Fixed/Expression mode
   - Single-line expressions only
   - Wrapped in {{ ... }}
   - Ideal for quick transformations

   Code Node:
   - Separate node in workflow
   - Full multi-line code support
   - Complex logic implementation
   - JavaScript or Python
   - Ideal for extensive processing

2. Feature Availability:
   Inline Expressions:
   - Tournament Engine transformations
   - Built-in helper methods ($if, $itemIndex)
   - Direct access to current item
   - Type-specific transformations
   - Chainable operations

   Code Node:
   - Full programming language features
   - External module support (self-hosted)
   - Complex data structures
   - Custom functions
   - Loops and conditionals

3. Helper Methods:
   Inline-Only Methods:
   - $if()
   - $itemIndex
   - Type-specific transformations (.isEmail(), etc.)
   - Direct node references

   Code Node Methods:
   - $evaluateExpression()
   - $input methods
   - try/catch support
   - Custom error handling
   - Complex data manipulation

4. Use Case Scenarios:
   Use Inline Expressions When:
   - Simple data transformations needed
   - Single-line operations suffice
   - Type-specific validations required
   - Quick field calculations needed
   - Direct node data access required

   Use Code Node When:
   - Complex logic implementation needed
   - Multi-step processing required
   - Custom error handling needed
   - External libraries required
   - Bulk data processing needed

5. Data Access:
   Inline Expressions:
   - Direct access via $json
   - Node references via $("NodeName")
   - Current item context
   - Built-in variables

   Code Node:
   - Access via $input
   - Programmatic node access
   - Full data manipulation
   - Custom variable scope

6. Best Practices:
   Inline Expressions:
   - Keep expressions simple
   - Use appropriate data types
   - Chain operations efficiently
   - Consider readability
   - Use built-in transformations

   Code Node:
   - Structure code modularly
   - Handle errors properly
   - Comment complex logic
   - Consider performance
   - Follow language standards

Example Comparisons:
1. Simple Transformation:
   Inline: {{ $json.email.toLowerCase() }}
   Code:   item.json.email = item.json.email.toLowerCase();

2. Complex Logic:
   Inline: Not suitable
   Code:   Full implementation with loops, conditions, etc.

3. Data Validation:
   Inline: {{ $json.email.isEmail() }}
   Code:   Complex validation with multiple rules

4. Error Handling:
   Inline: {{ $ifEmpty($json.value, "default") }}
   Code:   try/catch with custom error handling

5. Method Combinations:
   Inline:
   - String + Array:
     {{ "a,b,c".split(",").removeDuplicates().join("-") }}
   
   - URL Processing:
     {{ $json.url.extractDomain().toUpperCase() }}
   
   - Data Processing:
     {{ $("PreviousNode").item.json.data.removeDuplicates().sum().round(2) }}

   Code:
   ```javascript
   // String + Array processing
   const result = input.split(",")
     .filter((v, i, a) => a.indexOf(v) === i)
     .join("-");

   // URL Processing
   const domain = new URL(json.url).hostname.toUpperCase();

   // Data Processing
   const data = $("PreviousNode").all()
     .map(item => item.json.data)
     .filter((v, i, a) => a.indexOf(v) === i)
     .reduce((sum, val) => sum + val, 0)
     .toFixed(2);
   ```

The choice between inline expressions and Code Node should: 