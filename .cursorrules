# General Rules
- Use Australian English spelling and conventions
- When trying to run commands (Agent or Compose), remember that you are on Windows with PowerShell Core

# MCP Rules
Search the web using Brave web search using the MCP tool first to see what people are saying before fixing anything that could be quite technical.
Use Code and Issue Researcher to assist with the following to enhance insight and learn the latest information/fixes:
Sequential thinking - for all tasks
Puppeteer - web browsing or web scraping
Server memory - for storing and refrerencing key information across moderate to complex work

For code indentation, uou must use spaces instead of tabs
# Instructions

During you interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Documentation Files

# MCP Server Tools Usage

## Strategic Tool Selection

- **Sequential Thinking:**
  - Use for multi-step operations requiring careful planning.
  - Maintain operational context to enable course correction.
  - Begin with a higher number of total thoughts (e.g. 8–12) for complex tasks.
  - Use branching to explore alternative approaches and mark revisions when needed.
  - Set `needsMoreThoughts=true` when new complexities arise.

- **Web Research (via Brave Search):**
  - Always conduct initial broad searches, then follow with detailed research.
  - Validate technical approaches, error handling strategies, and best practices.
  - Cross-reference multiple reputable sources before implementation.

- **Puppeteer Operations:**
  - Use for intricate web interactions and testing.
  - Implement chained operations with robust error handling, waits, and retries.
  - Optimise memory by closing pages when done and reusing browser instances.

- **Server Memory (Knowledge Graph):**
  - Maintain complex relationships and operational context.
  - Create entities for major components and concepts.
  - Map dependencies and document architectural decisions.
  - Regularly clean up obsolete entities and update relationships.

### Sequential Thinking
- Use for operations requiring multiple steps
- Essential for maintaining operational context
- Helps break down large changes into manageable chunks
- Enables course correction and revision of approach
- Key usage patterns:
  * Start with higher total_thoughts for complex tasks (8-12)
  * Use branching for exploring alternative approaches
  * Mark revisions when changing previous decisions
  * Set needsMoreThoughts=true when discovering new complexity
  * Use as tactical memory during long operations

### Web Research (Brave Search)
- Always search before implementing complex features
- Research patterns:
  * Start with broad concept search
  * Follow up with specific implementation details
  * Look for recent discussions and solutions
  * Cross-reference multiple sources
  * Use for validating approach before major changes
- Key usage:
  * Technical implementation patterns
  * Error handling strategies
  * Best practices validation
  * Community solutions to similar problems

### Puppeteer Operations
- Use for complex web interactions and testing
- Strategic patterns:
  * Chain operations with proper error handling
  * Use screenshots for validation points
  * Implement waits and retries for stability
  * Maintain session context across operations
- Memory management:
  * Close pages when done
  * Reuse browser instances when possible
  * Clear large objects after operations
  * Monitor memory usage in long sessions

## Operational Guidelines

### For Moderate Changes (30-100 lines):
1. Start with sequential thinking (5-8 thoughts)
2. Research similar implementations
3. Plan key validation points
4. Execute with regular state checks

### For Large Changes (100+ lines):
1. Begin with comprehensive sequential thinking (10+ thoughts)
2. Extensive research phase
3. Break into sub-operations
4. Regular validation checkpoints
5. Maintain operational memory through scratchpad


# Lessons

# Scratchpad

## n8n-nodes-billing-calculator Project - Project Phases Progress

### Completed Phases

#### Phase 1: Core Framework ✅
- [X] Implemented basic node structure
- [X] Created two operations: Process Billing and Validate Configuration
- [X] Implemented schema inference from examples
- [X] Created simple matching engine
- [X] Implemented basic validation
- [X] Fixed linter errors
- [X] Addressed import path issues with interfaces

#### Phase 2: Enhanced User Experience ✅
- [X] Created ResourceMapperUtils.ts for resource mapper functionality
- [X] Enhanced SchemaInterfaces.ts with new interface types
- [X] Updated BillingCalculator.node.ts with improved match configuration
- [X] Added output field mapping with multiple source types
- [X] Implemented schema visualization
- [X] Enhanced validation feedback with different severity levels
- [X] Addressed linter errors and execution context issues

### Current Phase

#### Phase 3: Advanced Features (In Progress)
- [X] Implement multi-key matching
  - [X] Create an enhanced matching engine in MatchingUtils.ts
  - [X] Extend ResourceMapperMatchConfig to support multiple field mappings
  - [X] Update indexPriceList to use composite keys
  - [X] Update UI in BillingCalculator.node.ts to support multiple field selections

- [X] Add custom calculation formulas
  - [X] Create FormulaUtils.ts for formula parsing and evaluation
  - [X] Implement basic arithmetic operations
  - [X] Support variables from both price list and usage records
  - [X] Add validation for formula correctness

- [X] Optimize batch processing for large datasets
  - [X] Create chunking mechanism for processing large datasets
  - [X] Implement progress reporting during execution
  - [X] Add memory optimization for large price lists
  - [X] Create configurable error handling options

- [X] Create debugging tools
  - [X] Add detailed logging options
  - [X] Create diagnostic output with match details
  - [X] Implement visualization of data flow

- [ ] Add comprehensive documentation
  - Create usage examples in README.md
  - Add inline documentation for complex functions
  - Create an overview document for architecture

- [ ] Create test workflows with samples
  - Create sample datasets for testing
  - Develop test workflows to validate features
  - Write automated tests

### Implementation Plan for Phase 3

1. **Multi-key matching (first priority):**
   - Update MatchingUtils.ts to support composite keys
   - Extend findMatch function to handle multiple match fields
   - Update UI in BillingCalculator.node.ts to support multiple field selections
   - Create helper functions to handle multi-field matching

2. **Custom calculation formulas:**
   - Create FormulaUtils.ts with formula parser
   - Implement basic arithmetic operations
   - Add support for common functions (SUM, AVG, MIN, MAX)
   - Create a validation function for formula syntax

3. **Batch processing optimization:**
   - Implement chunk-based processing in BillingCalculator.node.functions.ts
   - Add progress indicators in the node execution
   - Optimize memory usage with iterators and generators

4. **Debugging tools:**
   - Add logging levels in a new DebugUtils.ts
   - Create visualization helpers for match and calculation processes
   - Implement detailed error reporting

5. **Documentation and examples:**
   - Update README.md with comprehensive examples
   - Create example workflows in the .docs directory
   - Document best practices and limitations

6. **Testing:**
   - Create test datasets in a new samples directory
   - Implement automated tests for core functionality
   - Create integration tests for complete workflows

### Implementation Notes

1. **Resource Mapper Implementation:**
   - Used `fixedCollection` parameter with custom UI for visual mapping
   - Adapted output fields to support multiple source types
   - Created utility functions to convert between schemas and resource mapper options

2. **Schema Visualization:**
   - Implemented a standalone function for schema visualization
   - Added highlighting for match fields
   - Integrated visualization with validation output

3. **Enhanced Validation:**
   - Created interfaces for warnings and errors with severity levels
   - Added field-level validation
   - Improved error messages with specific context

4. **Multi-key Matching:**
   - Implemented support for multiple match fields with composite keys
   - Enhanced UI to allow selection of multiple fields
   - Ensured backward compatibility with single-key matching
   - Added validation for missing match fields

5. **Custom Calculation Formulas:**
   - Implemented formula parser and evaluator with support for variables
   - Added support for common math functions and operations
   - Enhanced UI for formula editing with validation
   - Added formula transformer to handle convenience variables

6. **Batch Processing Optimization:**
   - Created chunking mechanism for large datasets
   - Implemented progress reporting for long-running operations
   - Added configurable error handling options
   - Optimized memory usage for large price lists

7. **Debugging Tools:**
   - Created DebugUtils.ts with logging functions at different levels
   - Implemented diagnostic data collection for matches and formulas
   - Added data flow visualization for debugging
   - Created detailed record-level diagnostics

8. **Next Steps:**
   - Documentation and examples are next priority
   - Will create comprehensive usage examples and a project overview
   - Will implement test workflows with sample datasets
