---
description: examples;implementation;code;Practical code examples and implementation scenarios for Autotask webhook integration
globs: 
alwaysApply: false
---
---
description: examples;implementation;code;Practical code examples and implementation scenarios for Autotask webhook integration
---

# Webhook Implementation Examples

This guide provides practical examples for implementing Autotask webhooks in various scenarios.

## Basic Webhook Handler

### ASP.NET Core Implementation

```csharp
using Microsoft.AspNetCore.Mvc;
using System.Security.Cryptography;
using System.Text;

[ApiController]
[Route("api/[controller]")]
public class WebhookController : ControllerBase
{
    private readonly ILogger<WebhookController> _logger;
    private readonly string _webhookSecret;
    private readonly IWebhookProcessor _processor;

    public WebhookController(
        ILogger<WebhookController> logger,
        IConfiguration config,
        IWebhookProcessor processor)
    {
        _logger = logger;
        _webhookSecret = config["Autotask:WebhookSecret"];
        _processor = processor;
    }

    [HttpPost("autotask")]
    public async Task<IActionResult> HandleWebhook(
        [FromBody] dynamic payload,
        [FromHeader(Name = "X-Autotask-Signature")] string signature,
        [FromHeader(Name = "X-Autotask-WebhookId")] string webhookId)
    {
        try
        {
            // Log webhook receipt
            _logger.LogInformation($"Received webhook {webhookId} for processing");

            if (!ValidateSignature(payload.ToString(), signature))
            {
                _logger.LogWarning($"Invalid signature for webhook {webhookId}");
                return Unauthorized();
            }

            // Process with retry capability
            await _processor.ProcessWithRetryAsync(payload, webhookId);

            _logger.LogInformation($"Successfully processed webhook {webhookId}");
            return Ok();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, $"Failed processing webhook {webhookId}");
            // Return 500 to trigger Autotask retry mechanism
            return StatusCode(500);
        }
    }

    private bool ValidateSignature(string payload, string signature)
    {
        using var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(_webhookSecret));
        var computedHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(payload));
        var computedSignature = Convert.ToBase64String(computedHash);
        return signature.Equals(computedSignature);
    }
}
```

### PowerShell Implementation

```powershell
# Webhook endpoint using PowerShell Universal Dashboard
New-PSUEndpoint -Url "/webhook/autotask" -Method POST -ScriptBlock {
    param($Body, $Headers)

    # Load configuration
    $config = Get-Content "config.json" | ConvertFrom-Json
    $webhookSecret = $config.webhookSecret

    # Extract webhook details
    $signature = $Headers["X-Autotask-Signature"]
    $webhookId = $Headers["X-Autotask-WebhookId"]

    # Log webhook receipt
    Write-PSULog -Message "Received webhook $webhookId"

    # Validate signature
    if (-not (Validate-WebhookSignature -signature $signature -payload $Body -secret $webhookSecret)) {
        Write-PSULog -Message "Invalid signature for webhook $webhookId" -Level Warning
        Send-PSUResponse -StatusCode 401
        return
    }

    # Process payload
    try {
        $payload = $Body | ConvertFrom-Json

        # Log webhook details
        Write-PSULog -Message "Processing $($payload.EventType) event for $($payload.EntityType)"

        # Process based on event type with retry capability
        $result = switch ($payload.EventType) {
            "Create" { Handle-EntityCreated -payload $payload -webhookId $webhookId }
            "Update" { Handle-EntityUpdated -payload $payload -webhookId $webhookId }
            "Delete" { Handle-EntityDeleted -payload $payload -webhookId $webhookId }
        }

        if ($result.Success) {
            Write-PSULog -Message "Successfully processed webhook $webhookId"
            Send-PSUResponse -StatusCode 200
        } else {
            throw $result.Error
        }
    }
    catch {
        Write-PSULog -Message "Error processing webhook $webhookId: $_" -Level Error
        Send-PSUResponse -StatusCode 500
    }
}
```

## Example Payload Processing

### Ticket Creation Event

```json
{
  "EventType": "Create",
  "EntityType": "Ticket",
  "WebhookId": "12345-abcd-67890",
  "Entity": {
    "id": 12345,
    "title": "New Support Request",
    "status": 1,
    "priority": 2,
    "queueID": 123,
    "description": "Customer reported issue with...",
    "createDate": "2024-03-15T10:30:00Z",
    "source": 2,
    "assignedResourceID": 456
  },
  "FieldChanges": [
    {
      "FieldName": "status",
      "PreviousValue": null,
      "NewValue": 1
    }
  ]
}
```

### Processing Handler with Retry Logic

```powershell
function Handle-TicketCreated {
    param(
        $payload,
        $webhookId,
        $maxRetries = 3
    )

    # Extract ticket details
    $ticket = $payload.Entity
    $attempt = 1

    do {
        try {
            # Log attempt
            Write-PSULog "Processing ticket $($ticket.id) - Attempt $attempt"

            # Process ticket
            $result = Process-TicketCreation -ticket $ticket

            # Send notifications
            Send-TeamNotification -ticket $ticket
            Send-EmailNotification -ticket $ticket

            return @{
                Success = $true
                Data = $result
            }
        }
        catch {
            Write-PSULog "Attempt $attempt failed: $_" -Level Warning

            if ($attempt -ge $maxRetries) {
                return @{
                    Success = $false
                    Error = "Max retries exceeded: $_"
                }
            }

            # Exponential backoff
            Start-Sleep -Seconds ([Math]::Pow(2, $attempt))
            $attempt++
        }
    } while ($attempt -le $maxRetries)
}
```

## Integration Scenarios

### 1. Ticket Synchronisation with Field Filtering

```powershell
# Sync specific ticket fields to external system
function Sync-TicketToExternalSystem {
    param($ticketData, $fieldChanges)

    # Only sync if relevant fields changed
    $relevantFields = @('status', 'priority', 'assignedResourceID')
    $changedFields = $fieldChanges | Where-Object { $_.FieldName -in $relevantFields }

    if (-not $changedFields) {
        Write-PSULog "No relevant field changes, skipping sync"
        return
    }

    $externalSystemEndpoint = "https://api.external-system.com/tickets"
    $mappedData = @{
        externalId = $ticketData.id
        subject = $ticketData.title
        status = Convert-TicketStatus -status $ticketData.status
        priority = Convert-TicketPriority -priority $ticketData.priority
        assignedTo = Get-ResourceEmail -resourceId $ticketData.assignedResourceID
        lastModified = (Get-Date).ToUniversalTime().ToString("o")
    }

    $params = @{
        Uri = $externalSystemEndpoint
        Method = 'POST'
        Body = ($mappedData | ConvertTo-Json)
        ContentType = 'application/json'
        Headers = @{
            'Authorization' = "Bearer $env:EXTERNAL_SYSTEM_TOKEN"
            'X-Correlation-Id' = [Guid]::NewGuid().ToString()
        }
    }

    try {
        $response = Invoke-RestMethod @params
        Write-PSULog "Successfully synced ticket $($ticketData.id) to external system"
        return $response
    }
    catch {
        Write-PSULog "Failed to sync ticket: $_" -Level Error
        throw
    }
}
```

### 2. Contact Updates with Validation

```powershell
# Handle contact updates with data validation
function Process-ContactUpdate {
    param($contactData, $fieldChanges)

    # Validate required fields
    $requiredFields = @('firstName', 'lastName', 'emailAddress')
    foreach ($field in $requiredFields) {
        if ([string]::IsNullOrEmpty($contactData.$field)) {
            throw "Required field '$field' is missing or empty"
        }
    }

    # Validate email format
    if (-not ($contactData.emailAddress -match "^[^@]+@[^@]+\.[^@]+$")) {
        throw "Invalid email format: $($contactData.emailAddress)"
    }

    # Update CRM system
    $crmEndpoint = "https://crm-api.example.com/contacts"
    $mappedContact = @{
        id = $contactData.id
        firstName = $contactData.firstName
        lastName = $contactData.lastName
        email = $contactData.emailAddress
        phone = $contactData.phone
        company = $contactData.companyName
        lastModified = (Get-Date).ToUniversalTime().ToString("o")
        modifiedFields = ($fieldChanges | Select-Object -ExpandProperty FieldName)
    }

    try {
        $params = @{
            Uri = "$crmEndpoint/$($mappedContact.id)"
            Method = 'PUT'
            Body = ($mappedContact | ConvertTo-Json)
            ContentType = 'application/json'
            Headers = @{
                'X-Correlation-Id' = [Guid]::NewGuid().ToString()
            }
        }

        $response = Invoke-RestMethod @params
        Write-PSULog "Contact updated in CRM: $($mappedContact.id)"
        return $response
    }
    catch {
        Write-PSULog "Failed to update contact in CRM: $_" -Level Error
        throw
    }
}
```

For detailed error handling implementation, see [autotask-webhooks-api_errors.mdc](mdc:.cursor/rules/autotask-webhooks-api_errors.mdc)
