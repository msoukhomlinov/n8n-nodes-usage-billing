Analyze or implement n8n Code Node functionality following these guidelines:

1. Core Functionality:
   - Multi-line code support
   - JavaScript and Python support
   - Complex logic implementation
   - External module usage (self-hosted)
   - Full programming capabilities

2. Language Support:
   JavaScript:
   - Full access to n8n helpers
   - Node.js environment
   - External module support
   - Built-in transformations
   - Async/await support

   Python:
   - Standard library access
   - Basic n8n integration
   - Limited helper access
   - No JavaScript-specific features
   - Python environment constraints

3. Data Access Methods:
   $input Object:
   - $input.all() - Get all items
   - $input.first() - Get first item
   - $input.last() - Get last item
   - $input.item - Current item (per-item mode)
   - $input.params - Node configuration

   Context Variables:
   - $json - Current item data
   - $binary - Binary data
   - $execution - Execution details
   - $workflow - Workflow metadata
   - $context.noItemsLeft - Loop control

4. Code Implementation:
   Run Once for All Items:
   ```javascript
   const items = $input.all();
   const processedItems = items.map(item => {
     // Process each item
     return item;
   });
   return processedItems;
   ```

   Run Once per Item:
   ```javascript
   const item = $input.item;
   // Process single item
   return item;
   ```

5. External Module Usage (Self-hosted):
   Installation:
   ```bash
   npm install module-name
   ```

   Usage:
   ```javascript
   const module = require('module-name');
   // Use module functionality
   ```

6. Error Handling:
   Basic Error Handling:
   ```javascript
   try {
     // Code that might fail
   } catch (error) {
     console.error('Error:', error);
     throw error;
   }
   ```

   Data Validation:
   ```javascript
   if (!item.json.required_field) {
     throw new Error('Missing required field');
   }
   ```

7. Performance Optimization:
   - Optimize loops
   - Minimize API calls
   - Batch processing
   - Memory management
   - Resource utilization

8. Debugging Techniques:
   Console Logging:
   ```javascript
   console.log('Processing:', item.json);
   console.error('Error occurred:', error);
   ```

   State Tracking:
   ```javascript
   let processedCount = 0;
   items.forEach(item => {
     console.log(`Processing item ${++processedCount}`);
   });
   ```

9. Best Practices:
   Code Structure:
   - Modular functions
   - Clear variable names
   - Comprehensive comments
   - Error handling
   - Type checking

   Data Handling:
   - Validate inputs
   - Transform consistently
   - Handle edge cases
   - Maintain data structure
   - Document transformations

10. Limitations:
    - Sandboxed environment
    - Resource constraints
    - Module restrictions
    - State persistence
    - Security boundaries

11. Return Format:
    Single Item:
    ```javascript
    return {
      json: {
        // processed data
      }
    };
    ```

    Multiple Items:
    ```javascript
    return items.map(item => ({
      json: {
        // processed data
      }
    }));
    ```

Example Implementation:
```javascript
// Process multiple items with error handling
const processItems = () => {
  try {
    const items = $input.all();
    
    const processedItems = items.map(item => {
      // Validate
      if (!item.json.email) {
        throw new Error(`Missing email for item ${item.json.id}`);
      }

      // Transform
      item.json.email = item.json.email.toLowerCase();
      item.json.processedAt = new Date().toISOString();

      return {
        json: item.json,
        pairedItem: item.pairedItem
      };
    });

    return processedItems;
  } catch (error) {
    console.error('Processing error:', error);
    throw error;
  }
};

// Execute and return
return processItems();
```

The Code Node implementation should: 